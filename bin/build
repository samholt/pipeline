#!/usr/bin/env node

let fs = require("fs"),
    path = require("path"),
    exec = require("child_process").execSync,
    mustache = require("mustache"),
    distill = require("../distill-template/dist/template.js"),
    inlineAssets = require("./inline-assets"),
    analytics = require("./analytics");

// d3
let d3 = Object.assign({},
    require("d3-dsv"),
    require("d3-time-format"),
    require("d3-collection")
);

let jsdom = require("jsdom").jsdom,
    serializeDocument = require("jsdom").serializeDocument;

let RFC = d3.timeFormat("%a, %d %b %Y %H:%M:%S %Z");

let data = {
  now: Date.now(),
  nowRFC: RFC(Date.now())
}

// The journal data contains information about the distill journal:
data.journal = JSON.parse(fs.readFileSync("journal.json", "utf8"));

// Merge the posts data with the data housed in the local package.json files in each repo
data.posts = JSON.parse(fs.readFileSync("posts/posts.json", "utf8"));
data.posts.forEach((p) => {
  p.publishedDate = new Date(p.publishedDate);
  p.updatedDate = new Date(p.updatedDate);
  p.journal = data.journal;
  if (p.doiSuffix >= 1e5) console.error("DOI suffix overflow ", p.doiSuffix);
  p.doi = data.journal.doi + "." + ("000000" + p.doiSuffix).slice(-5);
});
data.posts.sort((a, b) => { return b.publishedDate - a.publishedDate; });

// TODO: should we nuke the docs/ folder prior to rebuilding?
console.log("POSTS -----------");
data.posts.forEach((post, i) => {
  console.log("Building post " + (i + 1) + " of " + data.posts.length + ": " + post.githubPath);
  let repoPath = path.join("posts", post.githubPath);
  exec("mkdir -p " + path.join("docs", post.distillPath));

  // TODO: alert if we don't have a thumbnail?

  // Copy the contents of the repo's public folder to the new location.
  let publishedPath = path.join("docs", post.distillPath);
  let originalPath = path.join(repoPath, "public/");
  try {
    exec("cp -r " + originalPath + " " + publishedPath);
  } catch (e) {
    console.error("No public folder for " + repoPath);
  }

  //Transform and rewrite all the html files that are direct children of public/
  fs.readdirSync(originalPath).forEach((f) => {
    if (path.extname(f) === ".html") {
      let htmlString = fs.readFileSync(path.join(originalPath, f), "utf8");
      var dom = jsdom(htmlString, {features: {ProcessExternalResources: false, FetchExternalResources: false}});
      distill.render(dom, post);
      distill.distillify(dom, post);
      let transformedHtml = serializeDocument(dom).replace("</body></html>", analytics + "</body></html>");
      fs.writeFileSync(path.join(publishedPath, f), transformedHtml, "utf8");
      // write out an archive page
      inlineAssets(dom, "img[src]", "src", publishedPath);
      inlineAssets(dom, 'link[rel="stylesheet"][href]', "href", publishedPath);
      inlineAssets(dom, "script[src]", "src", publishedPath);
      inlineAssets(dom, "video[src]", "src", publishedPath);
      inlineAssets(dom, "video > source[src]", "src", publishedPath);
      inlineAssets(dom, "audio[src]", "src", publishedPath);
      inlineAssets(dom, "audio > source[src]", "src", publishedPath);
      let archiveHtml = serializeDocument(dom)
      fs.writeFileSync(path.join(publishedPath, f.replace(".html", ".archive.html")), archiveHtml, "utf8");
    }
  });

  // Generate crossref
  let crossrefXml = distill.generateCrossref(post);
  fs.writeFileSync(path.join(publishedPath, "crossref.xml"), crossrefXml, "utf8");

});

// Commentary
data.commentaries = data.posts.filter(p => {
  return p.tags.indexOf("commentary") !== -1;
});

// Articles
data.articles = data.posts.filter(p => {
  return p.tags.indexOf("commentary") === -1;
});

// Nest the articles into volume/issues
data.issues = d3.nest()
    .key((d) => d.volume * 100 + d.issue)
    .sortKeys((a, b) => a - b)
    .entries(data.posts);

data.issues.forEach((issue) => {
  issue.volume = issue.values[0].volume;
  issue.issue = issue.values[0].issue;
});

let pageAssets = [
  "about",
  "journal"
].forEach(p => {
  exec(path.join("cp -rf pages/", p) + " docs/");
});

console.log("PAGES -----------");
let pages = [
  "about/index.html",
  "archive-info/index.html",
  "faq/index.html",
  "guide/index.html",
  "index.html",
  "journal/index.html",
  "prize/index.html"
];
pages.forEach(function(p, i) {
  console.log("Building page " + (i + 1) + " of " + pages.length + ": " + p);
  renderPage(p, data);
});
console.log("-----------");

fs.writeFileSync("docs/rss.xml", mustache.render(fs.readFileSync("pages/rss.xml", "utf8"), data));
exec("cp distill-template/dist/template.js docs/template.v1.js");
exec("cp distill-template/dist/template.js.map docs/template.v1.js.map");
exec("cp pages/CNAME docs/");

function renderPage(location, data) {
  let indexString = mustache.render(fs.readFileSync(path.join("pages/",location), "utf8") + analytics, data);
  var indexDom = jsdom(indexString, {features: {ProcessExternalResources: false, FetchExternalResources: false}});
  distill.render(indexDom, data);
  distill.distillify(indexDom, data);
  exec("mkdir -p " + path.dirname(path.join("docs", location)));
  fs.writeFileSync(path.join("docs/", location), serializeDocument(indexDom));
}
